<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>L2 C4: –°–ø–æ–π–ª–µ—Ä –ö–∞—Ç–∞–∫–æ–º–±</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0a;
      --wall: #222;
      --floor: #111;
      --gold: #ffd700;
      --red: #ff4444;
      --green: #44ff44;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background: var(--bg);
      color: #ffcc80;
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
      user-select: none;
      touch-action: none;
    }
    #game { display: flex; flex-direction: column; height: 100vh; }
    canvas {
      image-rendering: pixelated;
      background: var(--floor);
      box-shadow: 0 0 30px #330000 inset;
      flex: 1;
    }
    #ui {
      padding: 15px;
      background: #111;
      border-top: 3px solid #444;
      font-size: 12px;
    }
    .bar {
      height: 20px;
      background: #222;
      border: 2px solid #555;
      margin: 10px 0;
      border-radius: 10px;
      overflow: hidden;
    }
    .fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #feca57, #a0e7a0);
      border-radius: 8px;
      transition: width 0.4s ease;
    }
    .label {
      margin: 8px 0 4px;
      color: #ffcc80;
      display: flex;
      justify-content: space-between;
    }
    #log {
      height: 100px;
      overflow-y: auto;
      background: #000;
      padding: 10px;
      border: 2px solid #444;
      margin-top: 15px;
      border-radius: 8px;
      font-size: 11px;
      color: #ccc;
    }
    h1 {
      font-size: 16px;
      color: #ff6b6b;
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #ff0000;
    }

    /* –î–ñ–û–ô–°–¢–ò–ö */
    #joystick {
      position: absolute;
      left: 20px; bottom: 20px;
      width: 130px; height: 130px;
      background: rgba(100,100,100,0.3);
      border: 4px solid #666;
      border-radius: 50%;
      z-index: 100;
    }
    #knob {
      position: absolute;
      width: 55px; height: 55px;
      background: radial-gradient(circle at 30% 30%, #ff6b6b, #cc0000);
      border-radius: 50%;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 20px #ff0000;
      transition: all 0.05s;
    }

    /* –°–ü–û–ô–õ */
    #spoilBtn {
      position: absolute;
      right: 20px; bottom: 20px;
      width: 100px; height: 100px;
      background: radial-gradient(circle, #ffd700, #cc9900);
      border-radius: 50%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      color: #000;
      font-weight: bold;
      box-shadow: 0 0 25px #ff0;
      z-index: 100;
    }
    #spoilBtn:active { transform: scale(0.85); }

    .spoil-effect {
      position: absolute;
      color: #ffd700;
      font-weight: bold;
      pointer-events: none;
      animation: float 1s ease-out forwards;
      z-index: 50;
    }
    @keyframes float {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="canvas"></canvas>

    <div id="joystick"><div id="knob"></div></div>
    <div id="spoilBtn">
      <div style="font-size:18px">‚ú®</div>
      –°–ü–û–ô–õ
    </div>

    <div id="ui">
      <h1>L2 C4: –ö–ê–¢–ê–ö–û–ú–ë–´</h1>
      <div class="label">–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span></div>
      <div class="bar"><div id="expBar" class="fill" style="width:0%"></div></div>

      <div class="label">–°–ø–æ–π–ª: <span id="spoilLevel">1</span> | –ü—É–¥—Ä—ã: <span id="crystals">0</span></div>
      <div class="bar"><div id="spoilBar" class="fill" style="width:0%"></div></div>

      <div class="label">–ê–¥–µ–Ω: <span id="adena">0</span> | –ú–∞—Ç-–ª—ã: <span id="mats">0</span></div>

      <div id="log"></div>
    </div>
  </div>

  <script>
    // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï ===
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    let entities = [];
    let player, pet = { level:1, exp:0, expToNext:100, spoilLevel:1, spoilExp:0, spoilToNext:100, adena:0, crystals:0, mats:0 };
    let camera = { x:0, y:0 };
    let joystick = { active:false, dx:0, dy:0 };
    let selectedTarget = null;

    const CONFIG = {
      ROOM_SIZE: 320,
      ATTACK_RANGE: 85,
      MOVE_SPEED: 4.2,
      SPOIL_CHANCE: 0.32,
      SPOIL_BONUS: 0.09,
      MOB_RESPAWN: 8000,
      GOAL_ADENA: 10000,
      ZOOM: 1.7
    };

    // === –†–ï–°–ê–ô–ó ===
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - 180;
    }
    window.addEventListener('resize', resize);
    resize();

    // === –î–ñ–û–ô–°–¢–ò–ö ===
    const joy = document.getElementById('joystick');
    const knob = document.getElementById('knob');
    let joyCenter = {};

    joy.addEventListener('touchstart', e => {
      e.preventDefault();
      joystick.active = true;
      const r = joy.getBoundingClientRect();
      joyCenter = { x: r.left + r.width/2, y: r.top + r.height/2 };
      updateJoy(e.touches[0]);
    });
    joy.addEventListener('touchmove', e => updateJoy(e.touches[0]));
    joy.addEventListener('touchend', () => {
      joystick.active = false;
      joystick.dx = joystick.dy = 0;
      knob.style.transform = 'translate(-50%, -50%)';
    });

    function updateJoy(t) {
      if (!joystick.active) return;
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const dist = Math.min(60, Math.hypot(dx, dy));
      const angle = Math.atan2(dy, dx);
      joystick.dx = Math.cos(angle) * dist / 60;
      joystick.dy = Math.sin(angle) * dist / 60;
      knob.style.transform = `translate(${dx * 0.7}px, ${dy * 0.7}px)`;
    }

    // === –°–ü–û–ô–õ ===
    document.getElementById('spoilBtn').addEventListener('touchstart', e => {
      e.preventDefault();
      if (!selectedTarget || selectedTarget.hp <= 0) {
        selectedTarget = entities.filter(e => e.type === 'mob' && e.hp > 0).sort((a,b) => dist(player,a) - dist(player,b))[0];
      }
      if (selectedTarget && !selectedTarget.spoiled) {
        player.spoil(selectedTarget);
      }
    });

    // === –ö–õ–ê–°–°–´ ===
    class Unit {
      constructor(x, y, type, symbol, color, hp, str, def) {
        this.x = x; this.y = y; this.type = type; this.symbol = symbol;
        this.color = color; this.hp = hp; this.maxHp = hp;
        this.str = str; this.def = def; this.target = null;
        this.spoiled = false; this.allianceId = Math.random() > 0.5 ? 1 : 2;
        this.bravery = type === 'gnome' ? Math.random() : 0.7;
        entities.push(this);
      }
      distTo(t) { return Math.hypot(this.x - t.x, this.y - t.y); }
      moveTo(tx, ty, s) {
        const dx = tx - this.x, dy = ty - this.y;
        const d = Math.hypot(dx, dy);
        if (d < 10) return;
        this.x += (dx/d) * s;
        this.y += (dy/d) * s;
      }
      attack(t) {
        if (!t || t.hp <= 0 || this.distTo(t) > CONFIG.ATTACK_RANGE) return;
        const dmg = Math.max(1, this.str - t.def + (Math.random()*5|0));
        t.hp -= dmg;
        log(`${this.symbol} ‚Üí ${t.symbol}: -${dmg}`, this.color);
        if (t.hp <= 0) { this.onKill(t); t.die(); }
      }
      spoil(t) {
        if (t.spoiled || t.type !== 'mob') return;
        const chance = CONFIG.SPOIL_CHANCE + (pet.spoilLevel-1)*CONFIG.SPOIL_BONUS;
        if (Math.random() < chance) {
          t.spoiled = true;
          const items = ['Animal Bone', 'Iron Ore', 'Craft Leather', 'Bone Dust', 'Crystal: D'];
          const item = items[Math.floor(Math.random()*items.length)];
          const amt = 1 + (Math.random()*2|0);
          if (item.includes('Crystal')) pet.crystals += amt;
          else pet.mats += amt;
          log(`SPOIL +${item} x${amt}`, '#ffd700');
          addEffect(t.x, t.y, `+${item}`);
          pet.spoilExp += 12 * amt;
          checkSpoil();
        } else {
          log('–ü—Ä–æ–≤–∞–ª...', '#888');
        }
      }
      onKill(t) {
        pet.adena += 60 + (Math.random()*80|0);
        pet.exp += 18;
        checkLevel();
        if (t.spoiled) { pet.adena += 120; log('+120 –∞–¥–µ–Ω!', '#ffcc80'); }
      }
      die() {
        if (this.type === 'player') {
          log('–¢–´ –£–ú–ï–†!', '#ff0000');
          pet.adena = Math.floor(pet.adena * 0.5);
          setTimeout(reset, 2000);
        }
        entities = entities.filter(e => e !== this);
      }
      getRoom() {
        return Math.floor(this.x / CONFIG.ROOM_SIZE) + Math.floor(this.y / CONFIG.ROOM_SIZE) * 2;
      }
      getRoomCenter(r) {
        const rx = r % 2, ry = Math.floor(r / 2);
        return { x: rx * CONFIG.ROOM_SIZE + CONFIG.ROOM_SIZE/2, y: ry * CONFIG.ROOM_SIZE + CONFIG.ROOM_SIZE/2 };
      }
      aiTick() {
        if (this.hp <= 0) return;
        const room = this.getRoom();
        const inRoom = entities.filter(e => e.getRoom() === room && e.hp > 0);

        // –ö–æ–Ω—Ç—Ä–∞—Ç–∞–∫–∞
        if (this.target && this.target.hp > 0) {
          this.moveTo(this.target.x, this.target.y, 2);
          this.attack(this.target);
          return;
        }

        if (this.type === 'gnome') {
          const gnomes = inRoom.filter(e => e.type === 'player' || e.type === 'gnome').length;
          const mobs = inRoom.filter(e => e.type === 'mob').length;
          if (gnomes > 2 && mobs < gnomes && Math.random() < 0.3) {
            this.die();
            log(`${this.symbol} –æ—á–∫—É–µ—Ç!`, '#ffcc80');
            return;
          }
          const freeMob = inRoom.find(e => e.type === 'mob' && !e.spoiled);
          if (freeMob) { this.target = freeMob; this.spoil(freeMob); }
        } else if (this.type === 'sk') {
          const fighting = inRoom.filter(e => e.target && (e.target.type === 'player' || e.target.type === 'gnome'));
          if (fighting.length >= 2) {
            const ally = fighting[0];
            this.target = ally.target;
          } else {
            const freeMob = inRoom.find(e => e.type === 'mob');
            if (freeMob) this.target = freeMob;
          }
        } else if (this.type === 'mob') {
          const nearest = inRoom.find(e => (e.type === 'player' || e.type === 'gnome' || e.type === 'sk'));
          if (nearest) this.target = nearest;
        }

        if (this.target) {
          this.moveTo(this.target.x, this.target.y, 1.8);
          this.attack(this.target);
        } else {
          const center = this.getRoomCenter(this.getRoom());
          this.moveTo(center.x, center.y, 1.5);
        }
      }
    }

    class Player extends Unit {
      constructor() { super(160, 160, 'player', '‚öíÔ∏è', '#ff6b6b', 250, 16, 9); }
      update() {
        if (joystick.active) {
          this.x += joystick.dx * CONFIG.MOVE_SPEED;
          this.y += joystick.dy * CONFIG.MOVE_SPEED;
        }
        this.x = Math.max(30, Math.min(this.x, CONFIG.ROOM_SIZE*2 - 30));
        this.y = Math.max(30, Math.min(this.y, CONFIG.ROOM_SIZE*2 - 30));

        if (selectedTarget && selectedTarget.hp > 0) {
          this.moveTo(selectedTarget.x, selectedTarget.y, CONFIG.MOVE_SPEED * 0.8);
          this.attack(selectedTarget);
        }
      }
    }

    // === –≠–§–§–ï–ö–¢–´ ===
    function addEffect(x, y, text) {
      const el = document.createElement('div');
      el.className = 'spoil-effect';
      el.textContent = text;
      el.style.left = x * CONFIG.ZOOM - camera.x + 'px';
      el.style.top = y * CONFIG.ZOOM - camera.y + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }

    // === –ò–ù–ò–¢ ===
    function init() {
      entities = [];
      player = new Player();
      for (let i = 0; i < 4; i++) {
        const c = player.getRoomCenter(i);
        new Unit(c.x-40, c.y, 'gnome', 'üßô', '#ffd700', 160, 13, 7);
        new Unit(c.x+40, c.y, 'gnome', 'üßô', '#ffd700', 160, 13, 7);
        new Unit(c.x, c.y+50, 'sk', 'üõ°Ô∏è', '#00ff88', 280, 19, 11);
        for (let j = 0; j < 3; j++) spawnMob();
      }
      setInterval(spawnMob, CONFIG.MOB_RESPAWN);
    }

    function spawnMob() {
      const r = Math.floor(Math.random()*4);
      const c = player.getRoomCenter(r);
      new Unit(c.x + Math.random()*80-40, c.y + Math.random()*80-40, 'mob', Math.random() > 0.5 ? 'üíÄ' : 'üëπ', '#ff4444', 90, 9, 5);
    }

    function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }

    function log(msg, color='#fff') {
      const d = document.createElement('div');
      d.textContent = msg;
      d.style.color = color;
      logEl.appendChild(d);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function checkLevel() {
      if (pet.exp >= pet.expToNext) { pet.level++; pet.exp = 0; pet.expToNext *= 1.5; log('–£–†–û–í–ï–ù–¨ UP!', '#00ff00'); }
      if (pet.spoilExp >= pet.spoilToNext) { pet.spoilLevel++; pet.spoilExp = 0; pet.spoilToNext *= 1.5; log('–°–ü–û–ô–õ UP!', '#ffd700'); }
      document.getElementById('level').textContent = pet.level;
      document.getElementById('expBar').style.width = (pet.exp / pet.expToNext * 100) + '%';
      document.getElementById('spoilLevel').textContent = pet.spoilLevel;
      document.getElementById('spoilBar').style.width = (pet.spoilExp / pet.spoilToNext * 100) + '%';
      document.getElementById('adena').textContent = pet.adena;
      document.getElementById('crystals').textContent = pet.crystals;
      document.getElementById('mats').textContent = pet.mats;
      if (pet.adena >= CONFIG.GOAL_ADENA) { log('–¢–´ ‚Äî –ú–ê–°–¢–ï–† –°–ü–û–ô–õ–ê!', '#ffd700'); }
    }

    function reset() { init(); }

    // === –†–ï–ù–î–ï–† ===
    function render() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.scale(CONFIG.ZOOM, CONFIG.ZOOM);
      ctx.translate(-camera.x, -camera.y);

      // –ö–∞—Ä—Ç–∞
      ctx.fillStyle = '#222';
      ctx.fillRect(0,0,CONFIG.ROOM_SIZE*2,CONFIG.ROOM_SIZE*2);
      ctx.strokeStyle = '#555';
      ctx.lineWidth = 4;
      for (let i=0; i<=2; i++) {
        ctx.beginPath();
        ctx.moveTo(i*CONFIG.ROOM_SIZE, 0);
        ctx.lineTo(i*CONFIG.ROOM_SIZE, CONFIG.ROOM_SIZE*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i*CONFIG.ROOM_SIZE);
        ctx.lineTo(CONFIG.ROOM_SIZE*2, i*CONFIG.ROOM_SIZE);
        ctx.stroke();
      }

      // –Æ–Ω–∏—Ç—ã
      entities.forEach(e => {
        if (e.hp <= 0) return;
        ctx.font = '36px Arial';
        ctx.fillText(e.symbol, e.x-18, e.y+12);
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(e.x-22, e.y-25, 44, 6);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(e.x-22, e.y-25, 44*(e.hp/e.maxHp), 6);
        if (e === selectedTarget) {
          ctx.strokeStyle = '#ffff00';
          ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(e.x, e.y, 25, 0, Math.PI*2); ctx.stroke();
        }
      });

      ctx.restore();
    }

    function updateCamera() {
      camera.x = player.x - canvas.width/(2*CONFIG.ZOOM);
      camera.y = player.y - canvas.height/(2*CONFIG.ZOOM);
      camera.x = Math.max(0, Math.min(camera.x, CONFIG.ROOM_SIZE*2 - canvas.width/CONFIG.ZOOM));
      camera.y = Math.max(0, Math.min(camera.y, CONFIG.ROOM_SIZE*2 - canvas.height/CONFIG.ZOOM));
    }

    // === –õ–£–ü ===
    function loop() {
      player.update();
      entities.forEach(e => { if (e !== player && e.hp > 0) e.aiTick(); });
      updateCamera();
      render();
      requestAnimationFrame(loop);
    }

    // === –ö–õ–ò–ö –ü–û –ú–û–ë–£ ===
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const tx = (e.touches[0].clientX - rect.left) / CONFIG.ZOOM + camera.x;
      const ty = (e.touches[0].clientY - rect.top) / CONFIG.ZOOM + camera.y;
      selectedTarget = entities.find(ent => ent !== player && ent.hp > 0 && dist(ent, {x:tx, y:ty}) < 60);
    });

    init();
    loop();
  </script>
</body>
</html>