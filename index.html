<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Pocket RPG: Micro-Sim</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0a;
      --wall: #111;
      --floor: #000; /* –§–æ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é —á–µ—Ä–Ω—ã–π */
      --red: #ff4444;
      --green: #44ff44;
      --player-color: #ffffff; /* –ë–µ–ª—ã–π –ø–∏–∫—Å–µ–ª—å */
      --gnome-color: #ffd700;   /* –ñ–µ–ª—Ç—ã–π –ø–∏–∫—Å–µ–ª—å NPC */
      --ui-height: 240px; 
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      background: var(--bg);
      color: #ffcc80;
      font-family: 'Press Start 2P', cursive;
      overflow: hidden;
      user-select: none;
      touch-action: none;
    }
    #game { 
      display: flex; 
      flex-direction: column; 
      height: 100vh; 
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    canvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      background: var(--floor);
      box-shadow: 0 0 30px #330000 inset;
      flex-grow: 1;
    }
    #ui-container {
      display: flex; 
      flex-direction: column; 
      height: var(--ui-height);
    }
    #ui {
      padding: 15px;
      background: #111;
      border-top: 3px solid #444;
      font-size: 12px;
      flex-shrink: 0;
    }
    #log {
      height: 100%;
      overflow-y: auto;
      background: #000;
      padding: 10px;
      border: 2px solid #444;
      margin-top: 5px;
      border-radius: 8px;
      font-size: 11px;
      color: #ccc;
      flex-grow: 1;
      max-height: 60px;
      order: 3;
    }

    .bar {
      height: 18px;
      background: #222;
      border: 2px solid #555;
      margin: 5px 0;
      border-radius: 9px;
      overflow: hidden;
    }
    .fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #feca57, #a0e7a0);
      border-radius: 6px;
      transition: width 0.4s ease;
    }
    .label {
      margin: 4px 0 2px;
      color: #ffcc80;
      display: flex;
      justify-content: space-between;
    }
    
    h1 {
      font-size: 16px;
      color: #ff6b6b;
      text-align: center;
      margin-bottom: 5px;
      text-shadow: 0 0 10px #ff0000;
    }

    .shop-btn {
        font-family:'Press Start 2P', cursive; 
        font-size:8px; 
        padding:5px; 
        margin: 2px;
        background: #333; 
        color: #ffcc80; 
        border: 2px solid #555; 
        border-radius:5px;
        flex-grow: 1;
        min-width: 0;
    }

    #statusBtn {
        position: absolute;
        right: 20px; 
        bottom: calc(20px + var(--ui-height));
        width: 100px; height: 100px;
        background: radial-gradient(circle, #00ff00, #009900);
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        color: #fff;
        font-weight: bold;
        box-shadow: 0 0 25px #00ff00;
        z-index: 100;
        border: 4px solid #00ff00;
    }
    
    .spoil-effect {
      position: absolute;
      color: #ffd700;
      font-weight: bold;
      pointer-events: none;
      animation: float 1s ease-out forwards;
      z-index: 50;
    }
    @keyframes float {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }

    /* –°–¢–ò–õ–ò –î–õ–Ø –í–´–ë–û–†–ê –ö–õ–ê–°–°–ê */
    #classSelect {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0, 0, 0, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 200;
        color: white;
        text-align: center;
    }
    .class-option {
        margin: 10px;
        padding: 15px 30px;
        background: #333;
        border: 2px solid #555;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        width: 80%;
        max-width: 300px;
    }
    .class-option:hover {
        background: #555;
    }
  </style>
</head>
<body>
  <div id="game">
    <canvas id="canvas"></canvas>

    <div id="statusBtn">
      <div style="font-size:18px">üü¢</div>
      FARM
    </div>
    
    <div id="classSelect">
        <h1>–í–´–ë–ï–†–ò –°–£–î–¨–ë–£ –ì–ù–û–ú–ê</h1>
        <p style="font-size:10px; margin: 15px 0;">(–ù–∞—á–∞–ª—å–Ω—ã–µ —Å—Ç–∞—Ç—ã)</p>
        <div class="class-option" onclick="selectClass('fighter')">
            –í–û–ò–ù –ì–ù–û–ú ‚öîÔ∏è<br><span style="font-size:9px; color: #ff6b6b;">STR: 18 / DEF: 7</span>
        </div>
        <div class="class-option" onclick="selectClass('spoiler')">
            –°–ü–û–ô–õ–ï–† üí∞<br><span style="font-size:9px; color: #ffd700;">STR: 16 / DEF: 8 / Spoil Lvl: 3</span>
        </div>
        <div class="class-option" onclick="selectClass('crafter')">
            –ú–ê–°–¢–ï–† (AFK) üõ†Ô∏è<br><span style="font-size:9px; color: #00ffff;">STR: 15 / DEF: 10 / HP Reg: 1/s</span>
        </div>
    </div>
    <div id="ui-container">
        <div id="ui">
            <h1>–ö–ê–¢–ê–ö–û–ú–ë–´ (Micro-Sim)</h1>
            <div class="label">–£—Ä–æ–≤–µ–Ω—å: <span id="level">1</span> (STR: <span id="str">16</span> | DEF: <span id="def">9</span>)</div>
            <div class="bar"><div id="expBar" class="fill" style="width:0%"></div></div>

            <div class="label">–°–ø–æ–π–ª LVL: <span id="spoilLevel">1</span> | –ö—Ä–∏—Å—Ç–∞–ª–ª–∏–∑–∞—Ü–∏—è: <span id="crystalChance">0%</span></div>
            <div class="bar"><div id="spoilBar" class="fill" style="width:0%"></div></div>

            <div class="label">–ê–¥–µ–Ω: <span id="adena">0</span> | –ü—É–¥—Ä—ã (C): <span id="crystals">0</span> | –ú–∞—Ç-–ª—ã (M): <span id="mats">0</span></div>
            <div class="label" style="font-size:10px; color:#ffd700;">SPOIL CHANCE BONUS: <span id="allySpoilBonus">0%</span> | HP Reg: <span id="hpReg">0</span>/s</div>
            
            <div style="display:flex; justify-content: space-around; margin-top:10px;">
                <button id="buyWeapon" class="shop-btn">–û—Ä—É–∂–∏–µ +1 STR [500 A]</button>
                <button id="buyArmor" class="shop-btn">–ë—Ä–æ–Ω—è +1 DEF [500 A]</button>
                <button id="upgradeSpd" class="shop-btn" style="background: #004400; border-color:#00ff88;">FARM SPD (+5%) [10 C]</button>
            </div>
            <div style="display:flex; justify-content: space-around; margin-top:5px;">
                <button id="buyHpReg" class="shop-btn" style="background:#550000; border-color:#ff0000;">HP REG (+1/s) [10 M]</button>
                <button id="upgradeCrystal" class="shop-btn" style="background: #000055; border-color:#0000ff;">CRYSTAL UP (+5%) [15 M]</button>
                <button id="upgradeSpoil" class="shop-btn" style="background: #555500; border-color:#ffff00;">SPOIL UP (+5%) [15 C]</button>
            </div>
        </div>
        <div id="log"></div>
    </div>
  </div>

  <script>
    // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï ===
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const logEl = document.getElementById('log');
    const classSelectScreen = document.getElementById('classSelect');
    
    let entities = [];
    let player, pet = { 
        level:1, exp:0, expToNext:100, 
        spoilLevel:1, spoilExp:0, spoilToNext:100, 
        adena:0, crystals:0, mats:0,
        weaponLevel: 0, armorLevel: 0,
        crystalChanceLevel: 0,
        spoilBonusLevel: 0, 
        farmSpeedLevel: 0, 
        hpRegenRate: 0, 
    };
    let camera = { x:0, y:0 }; 
    let selectedTarget = null;
    let mobSpawnInterval;
    
    const CLASS_STATS = {
        fighter: { baseStr: 18, baseDef: 7, baseHp: 230, spoilLvl: 1, initialRegen: 0, symbol: '‚ö™' },
        spoiler: { baseStr: 16, baseDef: 8, baseHp: 250, spoilLvl: 3, initialRegen: 0, symbol: '‚ö™' },
        crafter: { baseStr: 15, baseDef: 10, baseHp: 210, spoilLvl: 1, initialRegen: 1, symbol: '‚ö™' }
    };

    const CONFIG = {
      ROOM_SIZE: 320,
      ATTACK_RANGE: 300, 
      ATTACK_SPEED_BASE: 1000, 
      SPEED_REDUCTION_PER_LEVEL: 0.05, 
      SPOIL_CHANCE_BASE: 0.35, 
      CHANCE_PER_SPOIL_LEVEL: 0.05, 
      CRYSTAL_CHANCE_BASE: 0.10, 
      CRYSTAL_CHANCE_PER_LEVEL: 0.05,
      MOB_RESPAWN_TIME: 4000, 
      ZOOM: 1.7,
      PIXEL_SIZE: 10, // –†–∞–∑–º–µ—Ä –ø–∏–∫—Å–µ–ª—è –≤ –∏–≥—Ä–æ–≤–æ–º –º–∏—Ä–µ
    };
    
    const SHOP_COST = {
        WEAPON_BASE_A: 500,
        ARMOR_BASE_A: 500,
        FARM_SPEED_C: 10,
        HP_REGEN_M: 10,
        CRYSTAL_CHANCE_M: 15,
        SPOIL_CHANCE_C: 15
    };

    // === –§–£–ù–ö–¶–ò–Ø –í–´–ë–û–†–ê –ö–õ–ê–°–°–ê ===
    window.selectClass = function(className) {
        const stats = CLASS_STATS[className];
        
        // –°–±—Ä–æ—Å pet –¥–ª—è –Ω–æ–≤–æ–π –∏–≥—Ä—ã
        pet = { 
            level:1, exp:0, expToNext:100, spoilLevel: stats.spoilLvl, spoilExp:0, spoilToNext:100, 
            adena:0, crystals:0, mats:0, weaponLevel: 0, armorLevel: 0,
            crystalChanceLevel: 0, spoilBonusLevel: 0, farmSpeedLevel: 0, 
            hpRegenRate: stats.initialRegen, // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —Ä–µ–≥–µ–Ω
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–∫–∞ —Å –≤—ã–±—Ä–∞–Ω–Ω—ã–º–∏ —Å—Ç–∞—Ç–∞–º–∏
        player = new Player(stats.baseStr, stats.baseDef, stats.baseHp);
        
        // –°–∫—Ä—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ –∫–ª–∞—Å—Å–∞ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É
        classSelectScreen.style.display = 'none';
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
        resize();
        init();
        // –í–ê–ñ–ù–û: –†–µ—Å—Ç–∞—Ä—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∫–ª–∞—Å—Å–∞
        if (typeof regInterval !== 'undefined') clearInterval(regInterval);
        window.regInterval = setInterval(regenerationTick, 1000); 

        loop();
        log(`–ö–ª–∞—Å—Å "${className.toUpperCase()}" –≤—ã–±—Ä–∞–Ω! –í–ø–µ—Ä–µ–¥, –≤ –ö–∞—Ç–∞–∫–æ–º–±—ã.`, '#ffd700');
    }

    // === –†–ï–°–ê–ô–ó ===
    function resize() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight; 
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      if (player) {
          const c = player.getRoomCenter(0);
          player.x = c.x;
          player.y = c.y;
          camera.x = player.x - canvas.width / (2 * CONFIG.ZOOM);
          camera.y = player.y - canvas.height / (2 * CONFIG.ZOOM);
      }
    }
    window.addEventListener('resize', resize);
    
    // === –ê–í–¢–û–ö–†–ò–°–¢–ê–õ–õ–ò–ó–ê–¶–ò–Ø/–†–ï–ì–ï–ù–ï–†–ê–¶–ò–Ø (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ===
    function autoCrystallize() {
        if (pet.mats <= 0) return;
        const chance = CONFIG.CRYSTAL_CHANCE_BASE + pet.crystalChanceLevel * CONFIG.CRYSTAL_CHANCE_PER_LEVEL;
        pet.mats--; 
        if (Math.random() < chance) {
            pet.crystals += 1; 
            log(`[CRYSTAL] +1 C`, '#00ffff');
        } 
        checkLevel();
    }
    
    function regenerationTick() {
        if (player && player.hp > 0 && pet.hpRegenRate > 0) {
            player.heal(pet.hpRegenRate * 1); 
        }
        if (pet.mats > 0) {
             autoCrystallize();
        }
    }
    
    // === –ö–õ–ê–°–°–´ ===
    class Unit {
      constructor(x, y, type, symbol, color, hp, str, def, mobLvl=1) {
        this.x = x; this.y = y; this.type = type; this.symbol = symbol;
        this.color = color; this.hp = hp; this.maxHp = hp;
        this.baseStr = str; this.baseDef = def; 
        this.mobLvl = mobLvl; 
        this.target = null;
        this.spoiled = false; 
        this.lastAttack = 0; 
        entities.push(this);
      }
      
      get str() {
          if (this.type === 'player') return this.baseStr + pet.weaponLevel;
          return this.baseStr;
      }
      
      get def() {
          if (this.type === 'player') return this.baseDef + pet.armorLevel;
          return this.baseDef;
      }
      
      distTo(t) { return Math.hypot(this.x - t.x, this.y - t.y); }
      
      moveTo(tx, ty, s) { return true; } 
      
      attack(t) {
        const now = Date.now();
        let attackDelay = CONFIG.ATTACK_SPEED_BASE;
        
        if (this.type === 'player') {
             attackDelay *= (1 - pet.farmSpeedLevel * CONFIG.SPEED_REDUCTION_PER_LEVEL);
        }

        if (!t || t.hp <= 0 || this.distTo(t) > CONFIG.ATTACK_RANGE || now - this.lastAttack < attackDelay) return;
        
        this.lastAttack = now;

        if (this.type === 'player') {
            this.autoSpoil(t);
        }
        
        const dmg = Math.max(1, this.str - t.def + (Math.random()*3|0)); 
        t.hp -= dmg;
        log(`${this.symbol} ‚Üí ${t.symbol}: -${dmg}`, this.color);
        
        if (t.hp <= 0) { 
            this.onKill(t); 
            t.die(); 
            this.target = null;
        }
      }
      
      autoSpoil(t) {
        if (t.spoiled || t.type !== 'mob' || t.hp <= 0) return;
        
        const globalSpoilBonus = pet.spoilBonusLevel * CONFIG.CHANCE_PER_SPOIL_LEVEL;
        const chance = CONFIG.SPOIL_CHANCE_BASE + (pet.spoilLevel-1) * CONFIG.CHANCE_PER_SPOIL_LEVEL + globalSpoilBonus;
        
        if (Math.random() < chance) {
          t.spoiled = true;
          log(`[SPOIL] –£–°–ü–ï–•`, '#ffd700');
          addEffect(t.x, t.y, `SPOIL!`);
        }
      }
      
      autoSweep(t) {
          if (t.type !== 'mob' || !t.spoiled || t.hp > 0) return;
          const chance = CONFIG.SPOIL_CHANCE_BASE + (pet.spoilLevel-1) * CONFIG.CHANCE_PER_SPOIL_LEVEL;
          
          if (Math.random() < chance) {
              let dropType, amount;
              if (Math.random() < 0.5) { 
                  dropType = 'Crystal: D';
                  amount = 1 + (Math.random()*4|0);
                  pet.crystals += amount;
              } else {
                  const items = ['Animal Bone', 'Iron Ore', 'Craft Leather', 'Bone Dust'];
                  dropType = items[Math.floor(Math.random()*items.length)];
                  amount = 2 + (Math.random()*5|0);
                  pet.mats += amount;
              }
              log(`[SWEEP] +${dropType} x${amount}`, '#00ff00');
              addEffect(t.x, t.y, `+${dropType}`);
              pet.spoilExp += 20 * amount; 
              checkLevel();
          } else {
              log(`[SWEEP] –ü–†–û–í–ê–õ.`, '#ff0000');
          }
      }

      onKill(t) {
        if (t.spoiled) {
             this.autoSweep(t);
        } else {
             pet.adena += 100 + (Math.random()*150|0);
             pet.exp += 30;
        }
        checkLevel();
      }
      
      die() {
        if (this.type === 'player') { 
            log('–¢–´ –ü–ê–õ –í –ë–û–Æ. ‚öîÔ∏è', '#ff0000');
            pet.adena = Math.floor(pet.adena * 0.5);
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞ —ç–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ –∫–ª–∞—Å—Å–∞ –¥–ª—è "—Ä–µ—Å–ø–∞—É–Ω–∞"
            classSelectScreen.style.display = 'flex';
            clearInterval(mobSpawnInterval);
            clearInterval(window.regInterval);
            entities = [];
            return;
        }
        if (selectedTarget === this) selectedTarget = null;
        if (this.type === 'mob') {
            entities = entities.filter(e => e !== this);
            const room = this.getRoom();
            setTimeout(() => spawnMob(room), CONFIG.MOB_RESPAWN_TIME);
        }
      }
      
      getRoomCenter(r) {
        const rx = r % 2, ry = Math.floor(r / 2);
        return { x: rx * CONFIG.ROOM_SIZE + CONFIG.ROOM_SIZE/2, y: ry * CONFIG.ROOM_SIZE + CONFIG.ROOM_SIZE/2 };
      }

      aiTick() {
        if (this.hp <= 0) return;
        if (this.type === 'mob') {
          const nearest = entities.find(e => e.type === 'player' && dist(this, e) < CONFIG.ATTACK_RANGE * 2);
          if (nearest) this.target = nearest;

          if (this.target) {
            this.attack(this.target);
          }
        }
      }
    }

    class Player extends Unit {
      constructor(baseStr, baseDef, baseHp) { 
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–µ–ª—ã–π –ø–∏–∫—Å–µ–ª—å –∫–∞–∫ —Å–∏–º–≤–æ–ª
          super(160, 160, 'player', '‚ö™', 'var(--player-color)', baseHp, baseStr, baseDef, 0); 
          this.maxHp = baseHp;
      }
      
      heal(amount) { 
          this.hp = Math.min(this.maxHp, this.hp + amount); 
      }
      
      update() {
        const room = Math.floor(this.x / CONFIG.ROOM_SIZE) + Math.floor(this.y / CONFIG.ROOM_SIZE) * 2;
        const center = this.getRoomCenter(room);
        this.x = center.x;
        this.y = center.y;

        if (!selectedTarget || selectedTarget.hp <= 0) {
            selectedTarget = entities
                .filter(e => e.type === 'mob' && e.hp > 0 && dist(this, e) < CONFIG.ATTACK_RANGE * 2) 
                .sort((a,b) => dist(player,a) - dist(player,b))[0];
        } else if (selectedTarget && selectedTarget.hp <= 0) {
            selectedTarget = null;
        }

        if (selectedTarget && selectedTarget.hp > 0) {
            this.attack(selectedTarget);
        }
      }
    }

    // === –§–£–ù–ö–¶–ò–ò ===
    function addEffect(x, y, text) {
      const el = document.createElement('div');
      el.className = 'spoil-effect';
      el.textContent = text;
      el.style.left = (x * CONFIG.ZOOM - camera.x * CONFIG.ZOOM) + 'px';
      el.style.top = (y * CONFIG.ZOOM - camera.y * CONFIG.ZOOM) + 'px';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }
    
    function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
    
    function log(msg, color='#fff') {
      const d = document.createElement('div');
      d.textContent = msg;
      d.style.color = color;
      logEl.prepend(d);
      while (logEl.children.length > 30) { logEl.removeChild(logEl.lastChild); }
    }

    // === CHECKLEVEL & UI UPDATE ===
    function checkLevel() {
      if (pet.exp >= pet.expToNext) { 
        pet.level++; 
        pet.exp = pet.exp - pet.expToNext;
        pet.expToNext = Math.floor(pet.expToNext * 1.5 + 100); 
        player.maxHp = Math.floor(player.maxHp * 1.2); 
        player.heal(player.maxHp);
        log(`–£–†–û–í–ï–ù–¨ ${pet.level} UP! HP Max: ${player.maxHp}`, '#00ff00'); 
      }
      if (pet.spoilExp >= pet.spoilToNext) { 
        pet.spoilLevel++; 
        pet.spoilExp = pet.spoilExp - pet.spoilToNext; 
        pet.spoilToNext = Math.floor(pet.spoilToNext * 1.5 + 50); 
        log(`–°–ü–û–ô–õ –£–†–û–í–ï–ù–¨ ${pet.spoilLevel} UP!`, '#ffd700'); 
      }
      
      document.getElementById('level').textContent = pet.level;
      document.getElementById('str').textContent = player.str;
      document.getElementById('def').textContent = player.def;
      document.getElementById('expBar').style.width = (pet.exp / pet.expToNext * 100) + '%';
      
      document.getElementById('spoilLevel').textContent = pet.spoilLevel;
      document.getElementById('spoilBar').style.width = (pet.spoilExp / pet.spoilToNext * 100) + '%';
      
      document.getElementById('adena').textContent = pet.adena;
      document.getElementById('crystals').textContent = pet.crystals;
      document.getElementById('mats').textContent = pet.mats;
      
      document.getElementById('allySpoilBonus').textContent = (pet.spoilBonusLevel * CONFIG.CHANCE_PER_SPOIL_LEVEL * 100) + '%';
      document.getElementById('hpReg').textContent = pet.hpRegenRate;
      document.getElementById('crystalChance').textContent = (CONFIG.CRYSTAL_CHANCE_BASE * 100 + pet.crystalChanceLevel * CONFIG.CRYSTAL_CHANCE_PER_LEVEL * 100) + '%';
      
      const hpWidth = (player.hp / player.maxHp * 100);
      canvas.style.boxShadow = `0 0 30px ${hpWidth < 20 ? '#ff0000' : '#330000'} inset`;
      
      document.getElementById('buyWeapon').textContent = `–û—Ä—É–∂–∏–µ +${pet.weaponLevel+1} [${SHOP_COST.WEAPON_BASE_A * (pet.weaponLevel + 1)} A]`;
      document.getElementById('buyArmor').textContent = `–ë—Ä–æ–Ω—è +${pet.armorLevel+1} [${SHOP_COST.ARMOR_BASE_A * (pet.armorLevel + 1)} A]`;
      document.getElementById('upgradeSpd').textContent = `FARM SPD (+${pet.farmSpeedLevel+1}%) [${SHOP_COST.FARM_SPEED_C * (pet.farmSpeedLevel + 1)} C]`;
      document.getElementById('buyHpReg').textContent = `HP REG (+1/s) [${SHOP_COST.HP_REGEN_M * (pet.hpRegenRate + 1)} M]`;
    }

    function checkSpoil() { checkLevel(); } 
    function reset() { /* ... */ }

    // === –ò–ù–ò–¢ & –°–ü–ê–í–ù ===
    function init() {
      entities = [];
      
      const c = player.getRoomCenter(0);
      player.x = c.x;
      player.y = c.y;
      
      // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ö–ê–ú–ï–†–´
      resize(); 
      camera.x = player.x - canvas.width / (2 * CONFIG.ZOOM);
      camera.y = player.y - canvas.height / (2 * CONFIG.ZOOM);

      for (let i = 0; i < 4; i++) {
        const mobLvl = 10 + i * 5; 
        for (let j = 0; j < 5; j++) spawnMob(i, mobLvl); 
      }
      
      if (mobSpawnInterval) clearInterval(mobSpawnInterval);
      mobSpawnInterval = setInterval(spawnMob, CONFIG.MOB_RESPAWN_TIME);
      
      checkLevel();
    }

    function spawnMob(room = Math.floor(Math.random()*4), mobLvl = 10 + room * 5) {
      const mobsInRoom = entities.filter(e => e.type === 'mob' && e.getRoom() === room).length;
      if (mobsInRoom >= 7) return; 

      const c = player.getRoomCenter(room);
      let symbol, color;
      
      // –ú–æ–±—ã Catacomb: –û—Ä–∫–∏ (—Ç–µ–º–Ω–æ-–∑–µ–ª–µ–Ω—ã–π) –∏ –°–∫–µ–ª–µ—Ç—ã (–∫—Ä–∞—Å–Ω—ã–π)
      if (Math.random() < 0.5) {
          symbol = 'üî¥'; // –°–∫–µ–ª–µ—Ç/–ú–æ–±
          color = 'var(--mob-color)'; 
      } else {
          symbol = 'üü¢'; // –û—Ä–∫/–ì—É–ª—å
          color = 'var(--orc-color)';
      }

      new Unit(
        c.x + Math.random()*150-75, 
        c.y + Math.random()*150-75, 
        'mob', 
        symbol, 
        color, 
        90 + mobLvl*5, 
        9 + Math.floor(mobLvl/5), 
        5 + Math.floor(mobLvl/10), 
        mobLvl
      );
    }

    // === –õ–û–ì–ò–ö–ê –ú–ê–ì–ê–ó–ò–ù–ê ===
    document.getElementById('buyWeapon').addEventListener('click', () => {
        const cost = SHOP_COST.WEAPON_BASE_A * (pet.weaponLevel + 1);
        if (pet.adena >= cost) {
            pet.adena -= cost;
            pet.weaponLevel++;
            log(`–ö—É–ø–ª–µ–Ω–æ: –û—Ä—É–∂–∏–µ +${pet.weaponLevel}. STR: +1`, '#ff6b6b');
            checkLevel();
        } else { log(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–¥–µ–Ω—ã (–Ω—É–∂–Ω–æ ${cost} A)!`, '#ff0000'); }
    });

    document.getElementById('buyArmor').addEventListener('click', () => {
        const cost = SHOP_COST.ARMOR_BASE_A * (pet.armorLevel + 1);
        if (pet.adena >= cost) {
            pet.adena -= cost;
            pet.armorLevel++;
            log(`–ö—É–ø–ª–µ–Ω–æ: –ë—Ä–æ–Ω—è +${pet.armorLevel}. DEF: +1`, '#00ff88');
            checkLevel();
        } else { log(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∞–¥–µ–Ω—ã (–Ω—É–∂–Ω–æ ${cost} A)!`, '#ff0000'); }
    });

    document.getElementById('upgradeSpd').addEventListener('click', () => {
        const cost = SHOP_COST.FARM_SPEED_C * (pet.farmSpeedLevel + 1);
        if (pet.crystals >= cost) {
            pet.crystals -= cost;
            pet.farmSpeedLevel++;
            log(`–°–∫–æ—Ä–æ—Å—Ç—å —Ñ–∞—Ä–º–∞ +${pet.farmSpeedLevel}!`, '#00ff88');
            checkLevel();
        } else { log(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—É–¥—Ä (–Ω—É–∂–Ω–æ ${cost} C)!`, '#ff0000'); }
    });

    document.getElementById('buyHpReg').addEventListener('click', () => {
        const cost = SHOP_COST.HP_REGEN_M * (pet.hpRegenRate + 1);
        if (pet.mats >= cost) {
            pet.mats -= cost;
            pet.hpRegenRate++;
            log(`–†–µ–≥–µ–Ω HP +1/s!`, '#ff0000');
            checkLevel();
        } else { log(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ (–Ω—É–∂–Ω–æ ${cost} M)!`, '#ff0000'); }
    });
    
    document.getElementById('upgradeCrystal').addEventListener('click', () => {
        const cost = SHOP_COST.CRYSTAL_CHANCE_M;
        if (pet.mats >= cost) {
            pet.mats -= cost;
            pet.crystalChanceLevel++; 
            log(`–®–∞–Ω—Å –∫—Ä–∏—Å—Ç–∞–ª–ª–∏–∑–∞—Ü–∏–∏ —É–≤–µ–ª–∏—á–µ–Ω!`, '#00ffff');
            checkLevel();
        } else { log(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ (–Ω—É–∂–Ω–æ ${cost} M)!`, '#ff0000'); }
    });

    document.getElementById('upgradeSpoil').addEventListener('click', () => {
        const cost = SHOP_COST.SPOIL_CHANCE_C * (pet.spoilBonusLevel + 1);
        if (pet.crystals >= cost) {
            pet.crystals -= cost;
            pet.spoilBonusLevel++; 
            log(`–®–∞–Ω—Å Spoil —É–≤–µ–ª–∏—á–µ–Ω!`, '#ffd700');
            checkLevel();
        } else { log(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—É–¥—Ä (–Ω—É–∂–Ω–æ ${cost} C)!`, '#ff0000'); }
    });
    
    // === –†–ï–ù–î–ï–† & –õ–£–ü ===
    function render() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      
      // –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–∞–º–µ—Ä—É
      ctx.translate(-camera.x * CONFIG.ZOOM, -camera.y * CONFIG.ZOOM);
      ctx.scale(CONFIG.ZOOM, CONFIG.ZOOM);

      // –ö–∞—Ä—Ç–∞: –∏–º–∏—Ç–∞—Ü–∏—è –ø–∏–∫—Å–µ–ª—å–Ω–æ–≥–æ –º–∏—Ä–∞
      ctx.fillStyle = '#111';
      ctx.fillRect(0,0,CONFIG.ROOM_SIZE*2,CONFIG.ROOM_SIZE*2);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2; // –ë–æ–ª–µ–µ —Ç–æ–Ω–∫–∏–µ –ª–∏–Ω–∏–∏ –¥–ª—è "–∫–ª–µ—Ç–æ–∫"
      for (let i=0; i<=2; i++) {
        ctx.beginPath();
        ctx.moveTo(i*CONFIG.ROOM_SIZE, 0);
        ctx.lineTo(i*CONFIG.ROOM_SIZE, CONFIG.ROOM_SIZE*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, i*CONFIG.ROOM_SIZE);
        ctx.lineTo(CONFIG.ROOM_SIZE*2, i*CONFIG.ROOM_SIZE);
        ctx.stroke();
      }

      // –Æ–Ω–∏—Ç—ã (–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –∫–∞–∫ –ø–∏–∫—Å–µ–ª–∏)
      entities.forEach(e => {
        if (e.hp <= 0) return; 
        
        const pixelSize = CONFIG.PIXEL_SIZE;
        const halfPixel = pixelSize / 2;

        // 1. –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ –ü–∏–∫—Å–µ–ª—è –Æ–Ω–∏—Ç–∞
        // –ú–æ–±—ã: 1x1 –ø–∏–∫—Å–µ–ª—å
        // –ò–≥—Ä–æ–∫: 2x2 –ø–∏–∫—Å–µ–ª—è
        ctx.fillStyle = e.type === 'player' ? 'var(--player-color)' : e.color;
        
        if (e.type === 'player') {
            // –ò–≥—Ä–æ–∫ –∫–∞–∫ 2x2 –ø–∏–∫—Å–µ–ª—è –¥–ª—è –ª—É—á—à–µ–π –≤–∏–¥–∏–º–æ—Å—Ç–∏
            ctx.fillRect(e.x - pixelSize, e.y - pixelSize, pixelSize * 2, pixelSize * 2);
        } else {
            // –ú–æ–±—ã –∫–∞–∫ 1x1 –ø–∏–∫—Å–µ–ª—å
            ctx.fillRect(e.x - halfPixel, e.y - halfPixel, pixelSize, pixelSize);
        }
        
        // 2. –í—ã–¥–µ–ª–µ–Ω–∏–µ —Ü–µ–ª–∏/–°–ø–æ–π–ª–∞
        if (e === selectedTarget) {
          ctx.strokeStyle = '#ffff00';
          ctx.lineWidth = 1;
          ctx.beginPath(); ctx.arc(e.x, e.y, pixelSize * 3, 0, Math.PI*2); ctx.stroke();
        }
        
        if (e.spoiled) {
           // –ñ–µ–ª—Ç—ã–π –∫—Ä—É–≥ –≤–æ–∫—Ä—É–≥ —Å–ø–æ–π–ª–µ–Ω–Ω–æ–≥–æ –º–æ–±–∞
           ctx.strokeStyle = 'var(--gnome-color)'; 
           ctx.lineWidth = 2;
           ctx.beginPath(); ctx.arc(e.x, e.y, pixelSize * 2, 0, Math.PI*2); ctx.stroke();
        }
      });

      ctx.restore();
    }

    function updateCamera() {
      camera.x = player.x - canvas.width / (2 * CONFIG.ZOOM);
      camera.y = player.y - canvas.height / (2 * CONFIG.ZOOM);
    }

    function loop() {
      if (!player) {
          requestAnimationFrame(loop);
          return;
      }
      
      player.update();
      entities.forEach(e => { if (e !== player) e.aiTick(); });
      updateCamera();
      render();
      requestAnimationFrame(loop);
    }
    
    // === –û–ë–†–ê–ë–û–¢–ö–ê –ö–õ–ò–ö–ê ===
    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      
      const tx = (e.touches[0].clientX - rect.left) / CONFIG.ZOOM + camera.x;
      const ty = (e.touches[0].clientY - rect.top) / CONFIG.ZOOM + camera.y;
      
      selectedTarget = entities.find(ent => ent !== player && ent.hp > 0 && dist(ent, {x:tx, y:ty}) < 20); // –£–º–µ–Ω—å—à–µ–Ω–Ω—ã–π —Ä–∞–¥–∏—É—Å –∫–ª–∏–∫–∞
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    resize();
    loop();
  </script>
</body>
</html>
