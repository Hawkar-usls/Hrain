<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HRAIN v8.5.1 - –°–ò–ù–¢–ï–ó (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ)</title>
    
    <style>
        /* ========================================================================= */
        /* --- CSS –°–¢–ò–õ–¨ (HRAIN DARK THEME) --- */
        /* ========================================================================= */
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Roboto', 'Segoe UI', Arial, sans-serif; 
            background-color: #1a1a1a; 
            color: #e0e0e0; 
        }

        #app {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        /* 1. –ü–ê–ù–ï–õ–¨ –£–ü–†–ê–í–õ–ï–ù–ò–Ø */
        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 30px; 
            background-color: #2a2a2a; 
            border-bottom: 1px solid #3a3a3a; 
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4); 
            z-index: 100;
        }

        #controls h1 {
            margin: 0;
            font-size: 1.6em; 
            color: #00bcd4; 
            font-weight: 700; 
            letter-spacing: 1px; 
        }

        #controls button {
            padding: 8px 18px; 
            margin-left: 10px;
            border: 1px solid #555; 
            border-radius: 4px; 
            background-color: #3a3a3a;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 0.9em; 
            transition: background-color 0.2s, border-color 0.2s, color 0.2s;
        }

        #controls button:hover {
            background-color: #4a4a4a;
            border-color: #777;
            color: #ffffff;
        }

        #saveProfileButton { background-color: #00796b; color: white; border-color: #00796b; }
        #saveProfileButton:hover { background-color: #00897b; border-color: #00897b; }
        #toggleHintsButton { background-color: #5d6d7e; border-color: #5d6d7e; }
        #toggleHintsButton:hover { background-color: #6c8099; border-color: #6c8099; }


        /* 2. –†–ê–ë–û–ß–ê–Ø –û–ë–õ–ê–°–¢–¨ */
        #workspace {
            flex-grow: 1;
            overflow: hidden;
            position: relative;
            cursor: default;
            background-color: #1a1a1a; 
        }

        #workspace.panning, #workspace[style*="grabbing"] {
            cursor: grabbing !important;
        }

        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            mix-blend-mode: exclusion; 
        }

        /* 3. –£–ó–ï–õ (NODE) - –ö–†–£–ì/–°–§–ï–†–ê */
        .node {
            position: absolute;
            width: 150px; 
            height: 150px; 
            padding: 15px;
            background-color: rgba(51, 51, 51, 0.7); 
            border: 2px solid #555555; 
            border-radius: 50%; 
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5); 
            cursor: pointer;
            transition: border-color 0.3s, box-shadow 0.3s, background-color 0.3s, transform 0.3s; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transform-origin: center center;  
            z-index: 2; 
        }

        .node input[type="text"] {
            width: 100%;
            padding: 8px 5px; 
            border: none;
            background-color: transparent; 
            border-bottom: 2px solid #555555; 
            color: #e0e0e0; 
            text-align: center;
            font-size: 1em; 
            font-weight: 600;
            margin-top: 5px;
            outline: none;
            transition: border-bottom-color 0.2s;
        }

        .node input[type="text"]:focus {
            border-bottom-color: #00bcd4; 
        }
        
        .node:hover {
            border-color: #00bcd4; 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.6);
        }

        .node.selected {
            border-color: #4fc3f7 !important; 
            box-shadow: 0 0 12px rgba(79, 195, 247, 0.9) !important;
            z-index: 3; 
        }

        /* 4. –°–í–Ø–ó–¨ (LINK) */
        .link-line {
            position: absolute;
            height: 2px;  
            background-color: #888888; 
            transform-origin: 0 0;
            pointer-events: auto;  
            cursor: pointer;  
            z-index: 1; 
            transition: background-color 0.1s, height 0.1s;
            mix-blend-mode: normal; 
        }

        .link-line:hover {
            background-color: #e57373; 
            height: 3px;  
        }

        /* 5. –ü–û–î–°–ö–ê–ó–ö–ò */
        #hints {
            position: absolute; top: 50px; right: 15px; width: 300px; padding: 15px;
            background-color: rgba(45, 45, 45, 0.95); border-radius: 6px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s;
            border: 1px solid #555555; color: #c0c0c0; 
        }
        #hints.visible { opacity: 1; visibility: visible; }
        #hints h3 { margin-top: 0; color: #00bcd4; font-size: 1.2em; border-bottom: 1px solid #444444; padding-bottom: 10px; margin-bottom: 15px; }
        #hints ul { padding-left: 0; list-style-type: none; }
        #hints li { margin-bottom: 10px; font-size: 0.95em; color: #c0c0c0; position: relative; padding-left: 20px; }
        #hints li::before { content: "‚ñ∂"; color: #00bcd4; font-weight: bold; display: inline-block; width: 1.5em; margin-left: -1.5em; }
    </style>
</head>
<body>

    <div id="app">
        
        <div id="controls">
            <h1>HRAIN v8.5.1: –°–ò–ù–¢–ï–ó</h1>
            <div style="display: flex; align-items: center;">
                <button id="saveProfileButton">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</button>
                <button id="toggleHintsButton">–ü–æ–¥—Å–∫–∞–∑–∫–∏</button>
            </div>
        </div>

        <div id="workspace">
            <div id="canvas">
                </div>
        </div>
        
        <div id="hints">
            <h3>–ü–æ–¥—Å–∫–∞–∑–∫–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</h3>
            <ul>
                <li>**–°–æ–∑–¥–∞–Ω–∏–µ —É–∑–ª–∞ (–°—Ñ–µ—Ä—ã):** **–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫** (Double Click) –Ω–∞ –ø—É—Å—Ç–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ.</li>
                <li>**–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —É–∑–ª–∞:** –ù–∞–∂–º–∏—Ç–µ –Ω–∞ —É–∑–µ–ª –∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ (–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ).</li>
                <li>**–í–µ–Ω–Ω + –°—Ç—Ä—É–∫—Ç—É—Ä–∞:** –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —É–∑–ª—ã, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –ø–µ—Ä–µ–∫—Ä—ã—Ç–∏–µ (–í–µ–Ω–Ω), –∏ –ª–∏–Ω–∏–∏, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–π –ø—É—Ç—å.</li>
                <li>**–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ö–æ–ª—Å—Ç–∞ (–ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ):** –ù–∞–∂–º–∏—Ç–µ –∏ —É–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ **–ü–†–û–ë–ï–õ**, –∑–∞—Ç–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –º—ã—à—å—é.</li>
                <li>**–ú–∞—Å—à—Ç–∞–± —Ö–æ–ª—Å—Ç–∞ (Zoom):** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–ª–µ—Å–∏–∫–æ –º—ã—à–∏.</li>
                <li>**–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É–∑–ª–æ–≤ (–û—Ç–Ω–æ—à–µ–Ω–∏—è):**
                    <ol>
                        <li>**–û–¥–∏–Ω–∞—Ä–Ω—ã–π –∫–ª–∏–∫** –Ω–∞ –ø–µ—Ä–≤—ã–π —É–∑–µ–ª (–æ–Ω —Å—Ç–∞–Ω–µ—Ç **–≥–æ–ª—É–±—ã–º**).</li>
                        <li>**–û–¥–∏–Ω–∞—Ä–Ω—ã–π –∫–ª–∏–∫** –Ω–∞ –≤—Ç–æ—Ä–æ–π —É–∑–µ–ª –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–≤—è–∑–∏/–ª–∏–Ω–∏–∏.</li>
                    </ol>
                </li>
                <li>**–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ —É–∑–ª–∞:** **Ctrl/Cmd + –ö–ª–∏–∫** –¥–ª—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è; **Ctrl/Cmd + Shift + –ö–ª–∏–∫** –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è.</li>
                <li>**–£–¥–∞–ª–µ–Ω–∏–µ —É–∑–ª–∞ (–°—Ñ–µ—Ä—ã):** **–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫** (Double Click) –ø–æ —É–∑–ª—É.</li>
                <li>**–£–¥–∞–ª–µ–Ω–∏–µ —Å–≤—è–∑–∏/–ª–∏–Ω–∏–∏:** **–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫** (Double Click) –ø–æ —Å–∞–º–æ–π –ª–∏–Ω–∏–∏.</li>
            </ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            
            // --- 1. –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ —ç–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ ---
            const UNIQUE_PROFILE_KEY = 'hrain_user_data_synthesis'; 
            
            const workspace = document.getElementById('workspace');
            const canvas = document.getElementById('canvas');
            const saveProfileButton = document.getElementById('saveProfileButton');
            const toggleHintsButton = document.getElementById('toggleHintsButton');
            const hintsDiv = document.getElementById('hints');
            
            // --- 2. –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
            let nodeIdCounter = 0;
            let connectingNodeId = null; 
            
            let currentZoom = 1; 
            let panX = 0; 
            let panY = 0; 
            
            const zoomStep = 0.1; 
            const minZoom = 0.5; 
            const maxZoom = 3.0; 
            const nodeScaleStep = 0.2; 
            
            // --- –ö–û–ù–°–¢–ê–ù–¢–´ –î–õ–Ø –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò –í–ê–ñ–ù–û–°–¢–ò/–í–ï–ù–ù–ê ---
            const MAX_CONNECTIONS_FOR_BRIGHTNESS = 5; 
            const BASE_SCALE_FACTOR = 0.05; 
            const BASE_NODE_SCALE = 1.0; 
            const BASE_COLOR = [51, 51, 51]; 
            const ACCENT_COLOR = [0, 188, 212]; 
            const OPACITY = 0.7; 
            const NODE_SIZE = 150; 


            let isPanning = false; 
            let isDraggingNode = false; 
            let currentDraggedNode = null;
            let lastMouseX = 0;
            let lastMouseY = 0;

            // --- 3. –§–£–ù–ö–¶–ò–ò –ë–ï–ó–û–ü–ê–°–ù–û–ì–û –í–ó–ê–ò–ú–û–î–ï–ô–°–¢–í–ò–Ø –° –•–†–ê–ù–ò–õ–ò–©–ï–ú ---
            
            function safeGetItem(key) {
                try {
                    return localStorage.getItem(key);
                } catch (e) {
                    console.error("localStorage –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω:", e);
                    return null;
                }
            }

            function safeSetItem(key, value) {
                try {
                    localStorage.setItem(key, value);
                    return true;
                } catch (e) {
                    console.error("localStorage –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω:", e);
                    return false;
                }
            }

            // --- 4. –§–£–ù–ö–¶–ò–ò –¢–†–ê–ù–°–§–û–†–ú–ê–¶–ò–ò –ò –°–û–•–†–ê–ù–ï–ù–ò–Ø ---

            function applyTransform() {
                canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
            }

            function clearWorkspace() {
                canvas.innerHTML = '';
                connectingNodeId = null;
            }
            
            function saveState() {
                const nodesData = {};
                document.querySelectorAll('.node').forEach(nodeEl => {
                    const id = nodeEl.id;
                    nodesData[id] = {
                        id: id,
                        text: nodeEl.querySelector('input').value,
                        x: nodeEl.offsetLeft,
                        y: nodeEl.offsetTop,
                        connections: JSON.parse(nodeEl.dataset.connections),
                        nodeScale: parseFloat(nodeEl.dataset.scale || BASE_NODE_SCALE) 
                    };
                });

                const linksData = [];
                const uniqueLinks = new Set();
                document.querySelectorAll('.node').forEach(nodeEl => {
                    const sourceId = nodeEl.id;
                    const targetIds = JSON.parse(nodeEl.dataset.connections);
                    targetIds.forEach(targetId => {
                        const linkKey = [sourceId, targetId].sort().join('-');
                        if (!uniqueLinks.has(linkKey)) {
                            linksData.push({ source: sourceId, target: targetId });
                            uniqueLinks.add(linkKey);
                        }
                    });
                });

                const state = {
                    nodes: nodesData,
                    links: linksData, 
                    zoom: currentZoom,
                    panX: panX, 
                    panY: panY  
                };
                safeSetItem(UNIQUE_PROFILE_KEY, JSON.stringify(state));
            }
            
            function loadState() {
                clearWorkspace(); 

                const savedState = safeGetItem(UNIQUE_PROFILE_KEY);
                
                if (!savedState) {
                    const initialX = (workspace.offsetWidth / 2) - (NODE_SIZE / 2); 
                    const initialY = (workspace.offsetHeight / 2) - (NODE_SIZE / 2);  
                    
                    createNode(initialX, initialY, "–ù–∞—á–∞–ª—å–Ω–∞—è –°—Ñ–µ—Ä–∞"); 
                    saveState(); 
                    return;
                }
                
                const state = JSON.parse(savedState);
                
                let maxId = 0;
                Object.values(state.nodes || {}).forEach(data => {
                    createNode(data.x, data.y, data.text, data.id, data.connections, data.nodeScale); 
                    const currentIdNum = parseInt(data.id.replace('node-', ''));
                    if (currentIdNum > maxId) maxId = currentIdNum;
                });

                nodeIdCounter = maxId;

                (state.links || []).forEach(link => {
                    if (document.getElementById(link.source) && document.getElementById(link.target)) {
                        createLink(link.source, link.target); 
                    }
                });
                
                document.querySelectorAll('.node').forEach(nodeEl => {
                    updateNodeVisuals(nodeEl.id);
                });
                
                currentZoom = state.zoom || 1;
                panX = state.panX || 0;
                panY = state.panY || 0;
                
                applyTransform();
            }
            
            // --- 5. –§–£–ù–ö–¶–ò–ò –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–ò –ò –ú–ê–°–®–¢–ê–ë–ò–†–û–í–ê–ù–ò–Ø –£–ó–õ–û–í ---
            
            function updateNodeVisuals(nodeId) {
                const node = document.getElementById(nodeId);
                if (!node) return;

                const connections = JSON.parse(node.dataset.connections || '[]').length;
                
                // 1. –†–∞—Å—á–µ—Ç —Ü–≤–µ—Ç–∞ (–Ø—Ä–∫–æ—Å—Ç—å/–ù–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å)
                const brightnessFactor = Math.min(connections, MAX_CONNECTIONS_FOR_BRIGHTNESS) / MAX_CONNECTIONS_FOR_BRIGHTNESS;

                const r = Math.round(BASE_COLOR[0] + (ACCENT_COLOR[0] - BASE_COLOR[0]) * brightnessFactor);
                const g = Math.round(BASE_COLOR[1] + (ACCENT_COLOR[1] - BASE_COLOR[1]) * brightnessFactor);
                const b = Math.round(BASE_COLOR[2] + (ACCENT_COLOR[2] - BASE_COLOR[2]) * brightnessFactor);
                
                node.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${OPACITY})`;
                
                const borderR = Math.min(255, r + 50);
                const borderG = Math.min(255, g + 50);
                const borderB = Math.min(255, b + 50);
                node.style.borderColor = `rgb(${borderR}, ${borderG}, ${borderB})`;


                // 2. –†–∞—Å—á–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∞ (–í–∏–∑—É–∞–ª—å–Ω–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ)
                const baseScale = parseFloat(node.dataset.scale || BASE_NODE_SCALE);
                const connectionScale = connections * BASE_SCALE_FACTOR; 
                
                const newTotalScale = baseScale + connectionScale;
                
                node.style.transform = `scale(${newTotalScale})`; 
                node.dataset.totalScale = newTotalScale; 
                
                updateAllConnections(nodeId); // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–∏–Ω–∏–π, –µ—Å–ª–∏ —É–∑–µ–ª –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª—Å—è/–∏–∑–º–µ–Ω–∏–ª —Ä–∞–∑–º–µ—Ä
            }
            
            function updateNodeSize(node, baseScale) {
                node.dataset.scale = baseScale;
                updateNodeVisuals(node.id);
            }

            function changeNodeScale(nodeId, direction) {
                const node = document.getElementById(nodeId);
                let scale = parseFloat(node.dataset.scale || BASE_NODE_SCALE);
                
                let newScale = scale + direction * nodeScaleStep;
                
                newScale = Math.max(0.5, Math.min(3.0, newScale));
                newScale = Math.round(newScale * 10) / 10; 
                
                if (newScale !== scale) {
                    updateNodeSize(node, newScale);
                    saveState();
                }
            }
            
            function createNode(x, y, initialText = '', id = null, connections = [], nodeScale = BASE_NODE_SCALE) { 
                const nodeId = id || `node-${++nodeIdCounter}`;
                if (!id) nodeIdCounter = parseInt(nodeId.replace('node-', '')); 
                
                const node = document.createElement('div');
                node.className = 'node';
                node.id = nodeId;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                node.dataset.connections = JSON.stringify(connections); 
                node.dataset.scale = nodeScale; 
                
                updateNodeVisuals(nodeId); 
                
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = '–°—Ñ–µ—Ä–∞'; 
                input.value = initialText; 
                input.addEventListener('change', saveState); 
                input.addEventListener('blur', saveState);
                node.appendChild(input);
                
                canvas.appendChild(node);
                
                node.addEventListener('mousedown', startNodeDrag);
                
                // –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —É–∑–ª–∞
                node.addEventListener('dblclick', (e) => {
                    e.stopPropagation(); 
                    document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
                    connectingNodeId = null; 
                    deleteNodeAndConnections(nodeId);
                });
                
                // –õ–æ–≥–∏–∫–∞ –æ–¥–∏–Ω–∞—Ä–Ω–æ–≥–æ –∫–ª–∏–∫–∞ –¥–ª—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ò –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è
                node.addEventListener('click', (e) => {
                    if (isDraggingNode) return; 
                    e.stopPropagation(); 
                    
                    if (e.ctrlKey || e.metaKey) { 
                        e.preventDefault();
                        const direction = e.shiftKey ? -1 : 1;
                        changeNodeScale(nodeId, direction);
                        return;
                    }
                    
                    handleNodeConnect(nodeId);
                });
                
                return node;
            }
            
            function handleNodeConnect(nodeId) {
                const node = document.getElementById(nodeId);
                
                document.querySelectorAll('.node').forEach(n => {
                    if (n.id !== nodeId) n.classList.remove('selected');
                });

                if (connectingNodeId === null) {
                    // –í—ã–±–æ—Ä –ø–µ—Ä–≤–æ–≥–æ —É–∑–ª–∞
                    connectingNodeId = nodeId;
                    node.classList.add('selected');
                } else if (connectingNodeId === nodeId) {
                    // –û—Ç–º–µ–Ω–∞ –≤—ã–±–æ—Ä–∞
                    connectingNodeId = null;
                    node.classList.remove('selected');
                } else {
                    // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–ª–∏ –†–∞–∑—ä–µ–¥–∏–Ω–µ–Ω–∏–µ
                    const sourceId = connectingNodeId;
                    const targetId = nodeId;
                    
                    const sourceNode = document.getElementById(sourceId);
                    const targetNode = document.getElementById(targetId);
                    
                    const sConnections = JSON.parse(sourceNode.dataset.connections);
                    const tConnections = JSON.parse(targetNode.dataset.connections);
                    
                    if (sConnections.includes(targetId)) {
                        // –°–≤—è–∑—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç -> –£–¥–∞–ª—è–µ–º (–í–µ–Ω–Ω –∏ –õ–∏–Ω–∏—é)
                        deleteLink(sourceId, targetId); 
                    } else {
                        // –°–≤—è–∑—å –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç -> –°–æ–∑–¥–∞–µ–º (–í–µ–Ω–Ω –∏ –õ–∏–Ω–∏—é)
                        
                        // 1. –û–±–Ω–æ–≤–ª—è–µ–º –í–µ–Ω–Ω/–í–∞–∂–Ω–æ—Å—Ç—å
                        sConnections.push(targetId);
                        sourceNode.dataset.connections = JSON.stringify(sConnections);
                        
                        tConnections.push(sourceId); 
                        targetNode.dataset.connections = JSON.stringify(tConnections);
                        
                        updateNodeVisuals(sourceId);
                        updateNodeVisuals(targetId);
                        
                        // 2. –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é –ª–∏–Ω–∏—é
                        createLink(sourceId, targetId);
                        
                        saveState();
                    }

                    document.getElementById(sourceId).classList.remove('selected');
                    connectingNodeId = null;
                }
            }
            
            function createLink(sourceId, targetId) {
                const linkKey = [sourceId, targetId].sort().join('-'); 
                let line = document.getElementById(linkKey);
                
                if (line) line.remove();
                
                const sourceNode = document.getElementById(sourceId);
                const targetNode = document.getElementById(targetId);
                
                if (!sourceNode || !targetNode) return; 

                function findNodeBoundaryPoint(node, targetPoint) {
                    const nodeX = node.offsetLeft;
                    const nodeY = node.offsetTop;
                    const scale = parseFloat(node.dataset.totalScale || 1); 
                    const width = NODE_SIZE * scale; 
                    const centerX = nodeX + width / 2;
                    const centerY = nodeY + width / 2;
                    const dx = targetPoint.x - centerX;
                    const dy = targetPoint.y - centerY;

                    const angle = Math.atan2(dy, dx);
                    const radius = width / 2;
                    
                    return {
                        x: centerX + radius * Math.cos(angle),
                        y: centerY + radius * Math.sin(angle)
                    };
                }

                const sourceTotalScale = parseFloat(sourceNode.dataset.totalScale || 1);
                const targetTotalScale = parseFloat(targetNode.dataset.totalScale || 1);
                
                const sourceCenter = {
                    x: sourceNode.offsetLeft + (NODE_SIZE * sourceTotalScale) / 2,
                    y: sourceNode.offsetTop + (NODE_SIZE * sourceTotalScale) / 2
                };
                const targetCenter = {
                    x: targetNode.offsetLeft + (NODE_SIZE * targetTotalScale) / 2,
                    y: targetNode.offsetTop + (NODE_SIZE * targetTotalScale) / 2
                };

                const p1 = findNodeBoundaryPoint(sourceNode, targetCenter); 
                const p2 = findNodeBoundaryPoint(targetNode, sourceCenter); 

                const length = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * (180 / Math.PI);
                
                line = document.createElement('div');
                line.className = 'link-line';
                line.id = linkKey;
                line.style.width = `${length}px`;
                line.style.left = `${p1.x}px`;
                line.style.top = `${p1.y}px`;
                line.style.transform = `rotate(${angle}deg)`;
                line.dataset.source = sourceId;
                line.dataset.target = targetId;

                // –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —Å–≤—è–∑–∏
                line.addEventListener('dblclick', (e) => {
                    e.stopPropagation(); 
                    const sId = e.target.dataset.source;
                    const tId = e.target.dataset.target;
                    
                    if (sId && tId) {
                         deleteLink(sId, tId);
                    }
                });

                canvas.insertBefore(line, canvas.firstChild); 
            }
            
            function updateAllConnections(movedNodeId) {
                document.querySelectorAll('.link-line').forEach(line => {
                    if (line.dataset.source === movedNodeId || line.dataset.target === movedNodeId) {
                        createLink(line.dataset.source, line.dataset.target);
                    }
                });
            }
            
            function deleteLink(sourceId, targetId) {
                const linkKey = [sourceId, targetId].sort().join('-');
                const line = document.getElementById(linkKey);

                if (line) line.remove(); 

                const sourceNode = document.getElementById(sourceId);
                const targetNode = document.getElementById(targetId);

                if (sourceNode) {
                    let sConnections = JSON.parse(sourceNode.dataset.connections);
                    sourceNode.dataset.connections = JSON.stringify(sConnections.filter(id => id !== targetId));
                    updateNodeVisuals(sourceId);
                }

                if (targetNode) {
                    let tConnections = JSON.parse(targetNode.dataset.connections);
                    targetNode.dataset.connections = JSON.stringify(tConnections.filter(id => id !== sourceId));
                    updateNodeVisuals(targetId);
                }
                
                saveState();
            }

            function deleteNodeAndConnections(nodeId) {
                const node = document.getElementById(nodeId);
                if (!node) return;

                document.querySelectorAll('.link-line').forEach(line => {
                    if (line.dataset.source === nodeId || line.dataset.target === nodeId) {
                        line.remove();
                    }
                });

                document.querySelectorAll('.node').forEach(otherNode => {
                    const otherId = otherNode.id;
                    if (otherId === nodeId) return; 

                    let connections = JSON.parse(otherNode.dataset.connections);
                    const newConnections = connections.filter(id => id !== nodeId);
                    
                    if (newConnections.length !== connections.length) {
                        otherNode.dataset.connections = JSON.stringify(newConnections);
                        updateNodeVisuals(otherId); 
                    }
                });
                
                node.remove();
                if (connectingNodeId === nodeId) {
                    connectingNodeId = null;
                }
                
                saveState(); 
            }


            // --- 6. –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò DRAG & DROP, –ü–ê–ù–û–†–ê–ú–ò–†–û–í–ê–ù–ò–Ø –ò –ó–£–ú–ê ---
            
            function startNodeDrag(e) {
                if (e.button !== 0 || e.target.tagName === 'INPUT') return; 
                if (e.ctrlKey || e.metaKey) return; 

                e.preventDefault(); 
                isDraggingNode = false;
                currentDraggedNode = e.currentTarget;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                document.addEventListener('mousemove', dragNode);
                document.addEventListener('mouseup', stopNodeDrag);
                
                currentDraggedNode.classList.remove('selected'); 
                currentDraggedNode.style.zIndex = 4;
            }
            
            function dragNode(e) {
                if (!currentDraggedNode) return;
                
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                    isDraggingNode = true; 
                }
                
                // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –î–õ–Ø –¢–û–ß–ù–û–ì–û –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–Ø –ü–†–ò –ó–£–ú–ï
                let newLeft = currentDraggedNode.offsetLeft + dx / currentZoom;
                let newTop = currentDraggedNode.offsetTop + dy / currentZoom;

                currentDraggedNode.style.top = `${newTop}px`;
                currentDraggedNode.style.left = `${newLeft}px`; 
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                updateAllConnections(currentDraggedNode.id); // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–∏–Ω–∏–π –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏
            }
            
            function stopNodeDrag() {
                if (currentDraggedNode) {
                    if (isDraggingNode) {
                        saveState(); 
                    }
                    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º z-index
                    currentDraggedNode.style.zIndex = 2; 
                    currentDraggedNode = null;
                    isDraggingNode = false; 
                }
                document.removeEventListener('mousemove', dragNode);
                document.removeEventListener('mouseup', stopNodeDrag);
            }
            
            function startPanning(e) {
                if (e.target.closest('.node') || e.button !== 0 || e.target.tagName === 'INPUT') return; 
                
                if (e.code === 'Space' || e.key === ' ') {
                    if (e.target === workspace || e.target === canvas) {
                        e.preventDefault();
                        isPanning = true;
                        workspace.style.cursor = 'grabbing';
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                        
                        document.addEventListener('mousemove', panCanvas);
                        document.addEventListener('mouseup', stopPanning);
                    }
                }
            }
            
            function panCanvas(e) {
                if (!isPanning) return;
                e.preventDefault();
                
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                panX += dx;
                panY += dy;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                applyTransform();
            }
            
            function stopPanning() {
                if (isPanning) {
                    isPanning = false;
                    workspace.style.cursor = 'default';
                    saveState(); 
                }
                document.removeEventListener('mousemove', panCanvas);
                document.removeEventListener('mouseup', stopPanning);
            }
            
            function handleZoom(e) {
                e.preventDefault(); 
                
                const delta = e.deltaY > 0 ? -1 : 1;
                let newZoom = currentZoom + delta * zoomStep;
                
                newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
                newZoom = Math.round(newZoom * 100) / 100;
                
                const rect = workspace.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomRatio = newZoom / currentZoom;
                
                panX = mouseX - (mouseX - panX) * zoomRatio;
                panY = mouseY - (mouseY - panY) * zoomRatio;
                
                currentZoom = newZoom;
                applyTransform();
                saveState(); 
            }
            
            // --- 7. –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò –†–ï–ì–ò–°–¢–†–ê–¶–ò–Ø –í–°–ï–• –°–û–ë–´–¢–ò–ô ---

            function setupEventListeners() {
                saveProfileButton.addEventListener('click', saveState);
                toggleHintsButton.addEventListener('click', () => {
                    hintsDiv.classList.toggle('visible');
                    
                    if (hintsDiv.classList.contains('visible')) {
                        toggleHintsButton.textContent = '‚ùå –°–∫—Ä—ã—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏';
                    } else {
                        toggleHintsButton.textContent = '–ü–æ–¥—Å–∫–∞–∑–∫–∏';
                    }
                });

                workspace.addEventListener('dblclick', (e) => {
                    if (e.target !== workspace && e.target !== canvas) return;
                    
                    const rect = workspace.getBoundingClientRect();
                    const clientX = e.clientX - rect.left;
                    const clientY = e.clientY - rect.top;
                    
                    const rawX = (clientX - panX) / currentZoom;
                    const rawY = (clientY - panY) / currentZoom;
                    
                    const x = rawX - (NODE_SIZE / 2); 
                    const y = rawY - (NODE_SIZE / 2);
                    
                    createNode(x, y);
                    saveState();
                });
                
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                        e.preventDefault(); 
                        if (!isPanning) {
                            workspace.style.cursor = 'grab';
                        }
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        workspace.style.cursor = 'default';
                        isPanning = false; 
                    }
                });
                
                workspace.addEventListener('mousedown', startPanning); 
                workspace.addEventListener('wheel', handleZoom);
            }

            // --- 8. –ü–ï–†–í–ò–ß–ù–ê–Ø –ó–ê–ì–†–£–ó–ö–ê ---
            setupEventListeners();
            loadState(); 
        });
    </script>
</body>
</html>
